// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiodecoderdegradation)
public typealias AudioDecoderDegradation = __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiodecoderdegradationreason)
public typealias AudioDecoderDegradationReason = __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codeccategory)
public typealias CodecCategory = __x_ABI_CWindows_CMedia_CCore_CCodecCategory
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codeckind)
public typealias CodecKind = __x_ABI_CWindows_CMedia_CCore_CCodecKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectionmode)
public typealias FaceDetectionMode = __x_ABI_CWindows_CMedia_CCore_CFaceDetectionMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediadecoderstatus)
public typealias MediaDecoderStatus = __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestate)
public typealias MediaSourceState = __x_ABI_CWindows_CMedia_CCore_CMediaSourceState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatus)
public typealias MediaSourceStatus = __x_ABI_CWindows_CMedia_CCore_CMediaSourceStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedreason)
public typealias MediaStreamSourceClosedReason = __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceerrorstatus)
public typealias MediaStreamSourceErrorStatus = __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediatrackkind)
public typealias MediaTrackKind = __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mseappendmode)
public typealias MseAppendMode = __x_ABI_CWindows_CMedia_CCore_CMseAppendMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mseendofstreamstatus)
public typealias MseEndOfStreamStatus = __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msereadystate)
public typealias MseReadyState = __x_ABI_CWindows_CMedia_CCore_CMseReadyState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysisrecommendation)
public typealias SceneAnalysisRecommendation = __x_ABI_CWindows_CMedia_CCore_CSceneAnalysisRecommendation
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatakind)
public typealias TimedMetadataKind = __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerrorcode)
public typealias TimedMetadataTrackErrorCode = __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextdisplayalignment)
public typealias TimedTextDisplayAlignment = __x_ABI_CWindows_CMedia_CCore_CTimedTextDisplayAlignment
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextflowdirection)
public typealias TimedTextFlowDirection = __x_ABI_CWindows_CMedia_CCore_CTimedTextFlowDirection
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextfontstyle)
public typealias TimedTextFontStyle = __x_ABI_CWindows_CMedia_CCore_CTimedTextFontStyle
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextlinealignment)
public typealias TimedTextLineAlignment = __x_ABI_CWindows_CMedia_CCore_CTimedTextLineAlignment
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextscrollmode)
public typealias TimedTextScrollMode = __x_ABI_CWindows_CMedia_CCore_CTimedTextScrollMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextunit)
public typealias TimedTextUnit = __x_ABI_CWindows_CMedia_CCore_CTimedTextUnit
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextweight)
public typealias TimedTextWeight = __x_ABI_CWindows_CMedia_CCore_CTimedTextWeight
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextwrapping)
public typealias TimedTextWrapping = __x_ABI_CWindows_CMedia_CCore_CTimedTextWrapping
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextwritingmode)
public typealias TimedTextWritingMode = __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffectenabledchangedreason)
public typealias VideoStabilizationEffectEnabledChangedReason = __x_ABI_CWindows_CMedia_CCore_CVideoStabilizationEffectEnabledChangedReason
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor)
public final class AudioStreamDescriptor : WinRTClass, IMediaStreamDescriptor, IMediaStreamDescriptor2 {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IAudioStreamDescriptor
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIAudioStreamDescriptor
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIAudioStreamDescriptor>?) -> AudioStreamDescriptor? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static let _IAudioStreamDescriptorFactory: __ABI_Windows_Media_Core.IAudioStreamDescriptorFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.AudioStreamDescriptor"))
    public init(_ encodingProperties: UWP.AudioEncodingProperties!) {
        super.init(try! Self._IAudioStreamDescriptorFactory.CreateImpl(encodingProperties))
    }

    private lazy var _IMediaStreamDescriptor: __ABI_Windows_Media_Core.IMediaStreamDescriptor! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.isselected)
    public var isSelected : Bool {
        get { try! _IMediaStreamDescriptor.get_IsSelectedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.language)
    public var language : String {
        get { try! _IMediaStreamDescriptor.get_LanguageImpl() }
        set { try! _IMediaStreamDescriptor.put_LanguageImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.name)
    public var name : String {
        get { try! _IMediaStreamDescriptor.get_NameImpl() }
        set { try! _IMediaStreamDescriptor.put_NameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.encodingproperties)
    public var encodingProperties : UWP.AudioEncodingProperties! {
        get { try! _default.get_EncodingPropertiesImpl() }
    }

    private lazy var _IAudioStreamDescriptor2: __ABI_Windows_Media_Core.IAudioStreamDescriptor2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.leadingencoderpadding)
    public var leadingEncoderPadding : UInt32? {
        get { try! _IAudioStreamDescriptor2.get_LeadingEncoderPaddingImpl() }
        set { try! _IAudioStreamDescriptor2.put_LeadingEncoderPaddingImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.trailingencoderpadding)
    public var trailingEncoderPadding : UInt32? {
        get { try! _IAudioStreamDescriptor2.get_TrailingEncoderPaddingImpl() }
        set { try! _IAudioStreamDescriptor2.put_TrailingEncoderPaddingImpl(newValue) }
    }

    private lazy var _IMediaStreamDescriptor2: __ABI_Windows_Media_Core.IMediaStreamDescriptor2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.label)
    public var label : String {
        get { try! _IMediaStreamDescriptor2.get_LabelImpl() }
        set { try! _IMediaStreamDescriptor2.put_LabelImpl(newValue) }
    }

    private lazy var _IAudioStreamDescriptor3: __ABI_Windows_Media_Core.IAudioStreamDescriptor3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiostreamdescriptor.copy)
    public func copy() throws -> AudioStreamDescriptor! {
        try _IAudioStreamDescriptor3.CopyImpl()
    }

    deinit {
        _IMediaStreamDescriptor = nil
        _default = nil
        _IAudioStreamDescriptor2 = nil
        _IMediaStreamDescriptor2 = nil
        _IAudioStreamDescriptor3 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack)
public final class AudioTrack : WinRTClass, IMediaTrack {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaTrack
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaTrack
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaTrack>?) -> AudioTrack? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.id)
    public var id : String {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.label)
    public var label : String {
        get { try! _default.get_LabelImpl() }
        set { try! _default.put_LabelImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.language)
    public var language : String {
        get { try! _default.get_LanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.trackkind)
    public var trackKind : MediaTrackKind {
        get { try! _default.get_TrackKindImpl() }
    }

    private lazy var _IAudioTrack: __ABI_Windows_Media_Core.IAudioTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.getencodingproperties)
    public func getEncodingProperties() throws -> UWP.AudioEncodingProperties! {
        try _IAudioTrack.GetEncodingPropertiesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.name)
    public var name : String {
        get { try! _IAudioTrack.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.playbackitem)
    public var playbackItem : UWP.MediaPlaybackItem! {
        get { try! _IAudioTrack.get_PlaybackItemImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.supportinfo)
    public var supportInfo : AudioTrackSupportInfo! {
        get { try! _IAudioTrack.get_SupportInfoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.openfailed)
    public lazy var openFailed : Event<TypedEventHandler<AudioTrack?, AudioTrackOpenFailedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IAudioTrack else { return .init() }
          return try! this.add_OpenFailedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IAudioTrack.remove_OpenFailedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
        _IAudioTrack = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrackopenfailedeventargs)
public final class AudioTrackOpenFailedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IAudioTrackOpenFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIAudioTrackOpenFailedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIAudioTrackOpenFailedEventArgs>?) -> AudioTrackOpenFailedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrackopenfailedeventargs.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo)
public final class AudioTrackSupportInfo : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IAudioTrackSupportInfo
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIAudioTrackSupportInfo
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIAudioTrackSupportInfo>?) -> AudioTrackSupportInfo? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.decoderstatus)
    public var decoderStatus : MediaDecoderStatus {
        get { try! _default.get_DecoderStatusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.degradation)
    public var degradation : AudioDecoderDegradation {
        get { try! _default.get_DegradationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.degradationreason)
    public var degradationReason : AudioDecoderDegradationReason {
        get { try! _default.get_DegradationReasonImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.mediasourcestatus)
    public var mediaSourceStatus : MediaSourceStatus {
        get { try! _default.get_MediaSourceStatusImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.chaptercue)
public final class ChapterCue : WinRTClass, IMediaCue {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IChapterCue
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIChapterCue
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIChapterCue>?) -> ChapterCue? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.ChapterCue")))
    }

    private lazy var _IMediaCue: __ABI_Windows_Media_Core.IMediaCue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.chaptercue.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_DurationImpl() }
        set { try! _IMediaCue.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.chaptercue.id)
    public var id : String {
        get { try! _IMediaCue.get_IdImpl() }
        set { try! _IMediaCue.put_IdImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.chaptercue.starttime)
    public var startTime : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_StartTimeImpl() }
        set { try! _IMediaCue.put_StartTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.chaptercue.title)
    public var title : String {
        get { try! _default.get_TitleImpl() }
        set { try! _default.put_TitleImpl(newValue) }
    }

    deinit {
        _IMediaCue = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecinfo)
public final class CodecInfo : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ICodecInfo
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CICodecInfo
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CICodecInfo>?) -> CodecInfo? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecinfo.category)
    public var category : CodecCategory {
        get { try! _default.get_CategoryImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecinfo.displayname)
    public var displayName : String {
        get { try! _default.get_DisplayNameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecinfo.istrusted)
    public var isTrusted : Bool {
        get { try! _default.get_IsTrustedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecinfo.kind)
    public var kind : CodecKind {
        get { try! _default.get_KindImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecinfo.subtypes)
    public var subtypes : WindowsFoundation.AnyIVectorView<String>! {
        get { try! _default.get_SubtypesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecquery)
public final class CodecQuery : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ICodecQuery
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CICodecQuery
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CICodecQuery>?) -> CodecQuery? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.CodecQuery")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecquery.findallasync)
    public func findAllAsync(_ kind: CodecKind, _ category: CodecCategory, _ subType: String) throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<CodecInfo?>?>! {
        try _default.FindAllAsyncImpl(kind, category, subType)
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes)
public final class CodecSubtypes {
    private static let _ICodecSubtypesStatics: __ABI_Windows_Media_Core.ICodecSubtypesStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.CodecSubtypes"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformataac)
    public static var audioFormatAac : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatAacImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatadts)
    public static var audioFormatAdts : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatAdtsImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatalac)
    public static var audioFormatAlac : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatAlacImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatamrnb)
    public static var audioFormatAmrNB : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatAmrNBImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatamrwb)
    public static var audioFormatAmrWB : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatAmrWBImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatamrwp)
    public static var audioFormatAmrWP : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatAmrWPImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatdolbyac3)
    public static var audioFormatDolbyAC3 : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatDolbyAC3Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatdolbyac3spdif)
    public static var audioFormatDolbyAC3Spdif : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatDolbyAC3SpdifImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatdolbyddplus)
    public static var audioFormatDolbyDDPlus : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatDolbyDDPlusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatdrm)
    public static var audioFormatDrm : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatDrmImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatdts)
    public static var audioFormatDts : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatDtsImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatflac)
    public static var audioFormatFlac : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatFlacImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatfloat)
    public static var audioFormatFloat : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatFloatImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatmp3)
    public static var audioFormatMP3 : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatMP3Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatmpeg)
    public static var audioFormatMPeg : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatMPegImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatmsp1)
    public static var audioFormatMsp1 : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatMsp1Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatopus)
    public static var audioFormatOpus : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatOpusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatpcm)
    public static var audioFormatPcm : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatPcmImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatwmaudiolossless)
    public static var audioFormatWMAudioLossless : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatWMAudioLosslessImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatwmaudiov8)
    public static var audioFormatWMAudioV8 : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatWMAudioV8Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatwmaudiov9)
    public static var audioFormatWMAudioV9 : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatWMAudioV9Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.audioformatwmaspdif)
    public static var audioFormatWmaSpdif : String {
        get { try! _ICodecSubtypesStatics.get_AudioFormatWmaSpdifImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformat420o)
    public static var videoFormat420O : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormat420OImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatdv25)
    public static var videoFormatDV25 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatDV25Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatdv50)
    public static var videoFormatDV50 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatDV50Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatdvc)
    public static var videoFormatDvc : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatDvcImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatdvh1)
    public static var videoFormatDvh1 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatDvh1Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatdvhd)
    public static var videoFormatDvhD : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatDvhDImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatdvsd)
    public static var videoFormatDvsd : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatDvsdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatdvsl)
    public static var videoFormatDvsl : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatDvslImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformath263)
    public static var videoFormatH263 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatH263Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformath264)
    public static var videoFormatH264 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatH264Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformath264es)
    public static var videoFormatH264ES : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatH264ESImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformath265)
    public static var videoFormatH265 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatH265Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformathevc)
    public static var videoFormatHevc : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatHevcImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformathevces)
    public static var videoFormatHevcES : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatHevcESImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatm4s2)
    public static var videoFormatM4S2 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatM4S2Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmp43)
    public static var videoFormatMP43 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMP43Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmp4s)
    public static var videoFormatMP4S : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMP4SImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmp4v)
    public static var videoFormatMP4V : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMP4VImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmjpg)
    public static var videoFormatMjpg : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMjpgImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmpeg2)
    public static var videoFormatMpeg2 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMpeg2Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmpg1)
    public static var videoFormatMpg1 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMpg1Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmss1)
    public static var videoFormatMss1 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMss1Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatmss2)
    public static var videoFormatMss2 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatMss2Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatvp80)
    public static var videoFormatVP80 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatVP80Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatvp90)
    public static var videoFormatVP90 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatVP90Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatwmv1)
    public static var videoFormatWmv1 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatWmv1Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatwmv2)
    public static var videoFormatWmv2 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatWmv2Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatwmv3)
    public static var videoFormatWmv3 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatWmv3Impl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.codecsubtypes.videoformatwvc1)
    public static var videoFormatWvc1 : String {
        get { try! _ICodecSubtypesStatics.get_VideoFormatWvc1Impl() }
    }

}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.datacue)
public final class DataCue : WinRTClass, IMediaCue {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IDataCue
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIDataCue
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIDataCue>?) -> DataCue? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.DataCue")))
    }

    private lazy var _IMediaCue: __ABI_Windows_Media_Core.IMediaCue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.datacue.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_DurationImpl() }
        set { try! _IMediaCue.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.datacue.id)
    public var id : String {
        get { try! _IMediaCue.get_IdImpl() }
        set { try! _IMediaCue.put_IdImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.datacue.starttime)
    public var startTime : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_StartTimeImpl() }
        set { try! _IMediaCue.put_StartTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.datacue.data)
    public var data : UWP.AnyIBuffer! {
        get { try! _default.get_DataImpl() }
        set { try! _default.put_DataImpl(newValue) }
    }

    private lazy var _IDataCue2: __ABI_Windows_Media_Core.IDataCue2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.datacue.properties)
    public var properties : WindowsFoundation.PropertySet! {
        get { try! _IDataCue2.get_PropertiesImpl() }
    }

    deinit {
        _IMediaCue = nil
        _default = nil
        _IDataCue2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectedeventargs)
public final class FaceDetectedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IFaceDetectedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIFaceDetectedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIFaceDetectedEventArgs>?) -> FaceDetectedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectedeventargs.resultframe)
    public var resultFrame : FaceDetectionEffectFrame! {
        get { try! _default.get_ResultFrameImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffect)
public final class FaceDetectionEffect : WinRTClass, UWP.IMediaExtension {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IFaceDetectionEffect
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIFaceDetectionEffect
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIFaceDetectionEffect>?) -> FaceDetectionEffect? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IMediaExtension: __ABI_Windows_Media.IMediaExtension! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffect.setproperties)
    public func setProperties(_ configuration: WindowsFoundation.AnyIPropertySet!) throws {
        try _IMediaExtension.SetPropertiesImpl(configuration)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffect.desireddetectioninterval)
    public var desiredDetectionInterval : WindowsFoundation.TimeSpan {
        get { try! _default.get_DesiredDetectionIntervalImpl() }
        set { try! _default.put_DesiredDetectionIntervalImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffect.enabled)
    public var enabled : Bool {
        get { try! _default.get_EnabledImpl() }
        set { try! _default.put_EnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffect.facedetected)
    public lazy var faceDetected : Event<TypedEventHandler<FaceDetectionEffect?, FaceDetectedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_FaceDetectedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_FaceDetectedImpl($0)
       }
      )
    }()

    deinit {
        _IMediaExtension = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectdefinition)
public final class FaceDetectionEffectDefinition : WinRTClass, UWP.IVideoEffectDefinition {
    private typealias SwiftABI = __ABI_Windows_Media_Effects.IVideoEffectDefinition
    private typealias CABI = __x_ABI_CWindows_CMedia_CEffects_CIVideoEffectDefinition
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CEffects_CIVideoEffectDefinition>?) -> FaceDetectionEffectDefinition? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.FaceDetectionEffectDefinition")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectdefinition.activatableclassid)
    public var activatableClassId : String {
        get { try! _default.get_ActivatableClassIdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectdefinition.properties)
    public var properties : WindowsFoundation.AnyIPropertySet! {
        get { try! _default.get_PropertiesImpl() }
    }

    private lazy var _IFaceDetectionEffectDefinition: __ABI_Windows_Media_Core.IFaceDetectionEffectDefinition! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectdefinition.detectionmode)
    public var detectionMode : FaceDetectionMode {
        get { try! _IFaceDetectionEffectDefinition.get_DetectionModeImpl() }
        set { try! _IFaceDetectionEffectDefinition.put_DetectionModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectdefinition.synchronousdetectionenabled)
    public var synchronousDetectionEnabled : Bool {
        get { try! _IFaceDetectionEffectDefinition.get_SynchronousDetectionEnabledImpl() }
        set { try! _IFaceDetectionEffectDefinition.put_SynchronousDetectionEnabledImpl(newValue) }
    }

    deinit {
        _default = nil
        _IFaceDetectionEffectDefinition = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe)
public final class FaceDetectionEffectFrame : WinRTClass, WindowsFoundation.IClosable, UWP.IMediaFrame {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IFaceDetectionEffectFrame
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIFaceDetectionEffectFrame
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIFaceDetectionEffectFrame>?) -> FaceDetectionEffectFrame? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.close)
    public func close() throws {
        try _IClosable.CloseImpl()
    }

    private lazy var _IMediaFrame: __ABI_Windows_Media.IMediaFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.duration)
    public var duration : WindowsFoundation.TimeSpan? {
        get { try! _IMediaFrame.get_DurationImpl() }
        set { try! _IMediaFrame.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.extendedproperties)
    public var extendedProperties : WindowsFoundation.AnyIPropertySet! {
        get { try! _IMediaFrame.get_ExtendedPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.isdiscontinuous)
    public var isDiscontinuous : Bool {
        get { try! _IMediaFrame.get_IsDiscontinuousImpl() }
        set { try! _IMediaFrame.put_IsDiscontinuousImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.isreadonly)
    public var isReadOnly : Bool {
        get { try! _IMediaFrame.get_IsReadOnlyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.relativetime)
    public var relativeTime : WindowsFoundation.TimeSpan? {
        get { try! _IMediaFrame.get_RelativeTimeImpl() }
        set { try! _IMediaFrame.put_RelativeTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.systemrelativetime)
    public var systemRelativeTime : WindowsFoundation.TimeSpan? {
        get { try! _IMediaFrame.get_SystemRelativeTimeImpl() }
        set { try! _IMediaFrame.put_SystemRelativeTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.type)
    public var type : String {
        get { try! _IMediaFrame.get_TypeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.facedetectioneffectframe.detectedfaces)
    public var detectedFaces : WindowsFoundation.AnyIVectorView<UWP.DetectedFace?>! {
        get { try! _default.get_DetectedFacesImpl() }
    }

    deinit {
        _IClosable = nil
        _IMediaFrame = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.highdynamicrangecontrol)
public final class HighDynamicRangeControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IHighDynamicRangeControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIHighDynamicRangeControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIHighDynamicRangeControl>?) -> HighDynamicRangeControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.highdynamicrangecontrol.enabled)
    public var enabled : Bool {
        get { try! _default.get_EnabledImpl() }
        set { try! _default.put_EnabledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.highdynamicrangeoutput)
public final class HighDynamicRangeOutput : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IHighDynamicRangeOutput
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIHighDynamicRangeOutput
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIHighDynamicRangeOutput>?) -> HighDynamicRangeOutput? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.highdynamicrangeoutput.certainty)
    public var certainty : Double {
        get { try! _default.get_CertaintyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.highdynamicrangeoutput.framecontrollers)
    public var frameControllers : WindowsFoundation.AnyIVectorView<UWP.FrameController?>! {
        get { try! _default.get_FrameControllersImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imagecue)
public final class ImageCue : WinRTClass, IMediaCue {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IImageCue
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIImageCue
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIImageCue>?) -> ImageCue? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.ImageCue")))
    }

    private lazy var _IMediaCue: __ABI_Windows_Media_Core.IMediaCue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imagecue.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_DurationImpl() }
        set { try! _IMediaCue.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imagecue.id)
    public var id : String {
        get { try! _IMediaCue.get_IdImpl() }
        set { try! _IMediaCue.put_IdImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imagecue.starttime)
    public var startTime : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_StartTimeImpl() }
        set { try! _IMediaCue.put_StartTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imagecue.extent)
    public var extent : TimedTextSize {
        get { try! _default.get_ExtentImpl() }
        set { try! _default.put_ExtentImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imagecue.position)
    public var position : TimedTextPoint {
        get { try! _default.get_PositionImpl() }
        set { try! _default.put_PositionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imagecue.softwarebitmap)
    public var softwareBitmap : UWP.SoftwareBitmap! {
        get { try! _default.get_SoftwareBitmapImpl() }
        set { try! _default.put_SoftwareBitmapImpl(newValue) }
    }

    deinit {
        _IMediaCue = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.initializemediastreamsourcerequestedeventargs)
public final class InitializeMediaStreamSourceRequestedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IInitializeMediaStreamSourceRequestedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIInitializeMediaStreamSourceRequestedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIInitializeMediaStreamSourceRequestedEventArgs>?) -> InitializeMediaStreamSourceRequestedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.initializemediastreamsourcerequestedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.initializemediastreamsourcerequestedeventargs.randomaccessstream)
    public var randomAccessStream : UWP.AnyIRandomAccessStream! {
        get { try! _default.get_RandomAccessStreamImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.initializemediastreamsourcerequestedeventargs.source)
    public var source : MediaStreamSource! {
        get { try! _default.get_SourceImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.lowlightfusion)
public final class LowLightFusion {
    private static let _ILowLightFusionStatics: __ABI_Windows_Media_Core.ILowLightFusionStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.LowLightFusion"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.lowlightfusion.fuseasync)
    public static func fuseAsync(_ frameSet: WindowsFoundation.AnyIIterable<UWP.SoftwareBitmap?>!) -> WindowsFoundation.AnyIAsyncOperationWithProgress<LowLightFusionResult?, Double>! {
        return try! _ILowLightFusionStatics.FuseAsyncImpl(frameSet)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.lowlightfusion.maxsupportedframecount)
    public static var maxSupportedFrameCount : Int32 {
        get { try! _ILowLightFusionStatics.get_MaxSupportedFrameCountImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.lowlightfusion.supportedbitmappixelformats)
    public static var supportedBitmapPixelFormats : WindowsFoundation.AnyIVectorView<UWP.BitmapPixelFormat>! {
        get { try! _ILowLightFusionStatics.get_SupportedBitmapPixelFormatsImpl() }
    }

}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.lowlightfusionresult)
public final class LowLightFusionResult : WinRTClass, WindowsFoundation.IClosable {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ILowLightFusionResult
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CILowLightFusionResult
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CILowLightFusionResult>?) -> LowLightFusionResult? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.lowlightfusionresult.frame)
    public var frame : UWP.SoftwareBitmap! {
        get { try! _default.get_FrameImpl() }
    }

    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.lowlightfusionresult.close)
    public func close() throws {
        try _IClosable.CloseImpl()
    }

    deinit {
        _default = nil
        _IClosable = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder)
public final class MediaBinder : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaBinder
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaBinder
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaBinder>?) -> MediaBinder? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.MediaBinder")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder.source)
    public var source : MediaSource! {
        get { try! _default.get_SourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder.token)
    public var token : String {
        get { try! _default.get_TokenImpl() }
        set { try! _default.put_TokenImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder.binding)
    public lazy var binding : Event<TypedEventHandler<MediaBinder?, MediaBindingEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BindingImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BindingImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs)
public final class MediaBindingEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaBindingEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaBindingEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaBindingEventArgs>?) -> MediaBindingEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.seturi)
    public func setUri(_ uri: WindowsFoundation.Uri!) throws {
        try _default.SetUriImpl(uri)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setstream)
    public func setStream(_ stream: UWP.AnyIRandomAccessStream!, _ contentType: String) throws {
        try _default.SetStreamImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setstreamreference)
    public func setStreamReference(_ stream: UWP.AnyIRandomAccessStreamReference!, _ contentType: String) throws {
        try _default.SetStreamReferenceImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.mediabinder)
    public var mediaBinder : MediaBinder! {
        get { try! _default.get_MediaBinderImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.canceled)
    public lazy var canceled : Event<TypedEventHandler<MediaBindingEventArgs?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_CanceledImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_CanceledImpl($0)
       }
      )
    }()

    private lazy var _IMediaBindingEventArgs2: __ABI_Windows_Media_Core.IMediaBindingEventArgs2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setadaptivemediasource)
    public func setAdaptiveMediaSource(_ mediaSource: UWP.AdaptiveMediaSource!) throws {
        try _IMediaBindingEventArgs2.SetAdaptiveMediaSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setstoragefile)
    public func setStorageFile(_ file: UWP.AnyIStorageFile!) throws {
        try _IMediaBindingEventArgs2.SetStorageFileImpl(file)
    }

    private lazy var _IMediaBindingEventArgs3: __ABI_Windows_Media_Core.IMediaBindingEventArgs3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setdownloadoperation)
    public func setDownloadOperation(_ downloadOperation: UWP.DownloadOperation!) throws {
        try _IMediaBindingEventArgs3.SetDownloadOperationImpl(downloadOperation)
    }

    deinit {
        _default = nil
        _IMediaBindingEventArgs2 = nil
        _IMediaBindingEventArgs3 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediacueeventargs)
public final class MediaCueEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaCueEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaCueEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaCueEventArgs>?) -> MediaCueEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediacueeventargs.cue)
    public var cue : AnyIMediaCue! {
        get { try! _default.get_CueImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource)
public final class MediaSource : WinRTClass, UWP.IMediaPlaybackSource, WindowsFoundation.IClosable {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaSource2
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSource2
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSource2>?) -> MediaSource? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static let _IMediaSourceStatics: __ABI_Windows_Media_Core.IMediaSourceStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromadaptivemediasource)
    public static func createFromAdaptiveMediaSource(_ mediaSource: UWP.AdaptiveMediaSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromAdaptiveMediaSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommediastreamsource)
    public static func createFromMediaStreamSource(_ mediaSource: MediaStreamSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromMediaStreamSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommsestreamsource)
    public static func createFromMseStreamSource(_ mediaSource: MseStreamSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromMseStreamSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromimediasource)
    public static func createFromIMediaSource(_ mediaSource: AnyIMediaSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromIMediaSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromstoragefile)
    public static func createFromStorageFile(_ file: UWP.AnyIStorageFile!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromStorageFileImpl(file)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromstream)
    public static func createFromStream(_ stream: UWP.AnyIRandomAccessStream!, _ contentType: String) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromStreamImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromstreamreference)
    public static func createFromStreamReference(_ stream: UWP.AnyIRandomAccessStreamReference!, _ contentType: String) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromStreamReferenceImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromuri)
    public static func createFromUri(_ uri: WindowsFoundation.Uri!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromUriImpl(uri)
    }

    private static let _IMediaSourceStatics2: __ABI_Windows_Media_Core.IMediaSourceStatics2 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommediabinder)
    public static func createFromMediaBinder(_ binder: MediaBinder!) -> MediaSource! {
        return try! _IMediaSourceStatics2.CreateFromMediaBinderImpl(binder)
    }

    private static let _IMediaSourceStatics3: __ABI_Windows_Media_Core.IMediaSourceStatics3 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommediaframesource)
    public static func createFromMediaFrameSource(_ frameSource: UWP.MediaFrameSource!) -> MediaSource! {
        return try! _IMediaSourceStatics3.CreateFromMediaFrameSourceImpl(frameSource)
    }

    private static let _IMediaSourceStatics4: __ABI_Windows_Media_Core.IMediaSourceStatics4 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromdownloadoperation)
    public static func createFromDownloadOperation(_ downloadOperation: UWP.DownloadOperation!) -> MediaSource! {
        return try! _IMediaSourceStatics4.CreateFromDownloadOperationImpl(downloadOperation)
    }

    private lazy var _IMediaPlaybackSource: __ABI_Windows_Media_Playback.IMediaPlaybackSource! = getInterfaceForCaching()
    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.close)
    public func close() throws {
        try _IClosable.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.customproperties)
    public var customProperties : WindowsFoundation.ValueSet! {
        get { try! _default.get_CustomPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.duration)
    public var duration : WindowsFoundation.TimeSpan? {
        get { try! _default.get_DurationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.externaltimedmetadatatracks)
    public var externalTimedMetadataTracks : WindowsFoundation.AnyIObservableVector<TimedMetadataTrack?>! {
        get { try! _default.get_ExternalTimedMetadataTracksImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.externaltimedtextsources)
    public var externalTimedTextSources : WindowsFoundation.AnyIObservableVector<TimedTextSource?>! {
        get { try! _default.get_ExternalTimedTextSourcesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.isopen)
    public var isOpen : Bool {
        get { try! _default.get_IsOpenImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.openoperationcompleted)
    public lazy var openOperationCompleted : Event<TypedEventHandler<MediaSource?, MediaSourceOpenOperationCompletedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_OpenOperationCompletedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_OpenOperationCompletedImpl($0)
       }
      )
    }()

    private lazy var _IMediaSource3: __ABI_Windows_Media_Core.IMediaSource3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.reset)
    public func reset() throws {
        try _IMediaSource3.ResetImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.state)
    public var state : MediaSourceState {
        get { try! _IMediaSource3.get_StateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.statechanged)
    public lazy var stateChanged : Event<TypedEventHandler<MediaSource?, MediaSourceStateChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaSource3 else { return .init() }
          return try! this.add_StateChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaSource3.remove_StateChangedImpl($0)
       }
      )
    }()

    private lazy var _IMediaSource4: __ABI_Windows_Media_Core.IMediaSource4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.openasync)
    public func openAsync() throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IMediaSource4.OpenAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.adaptivemediasource)
    public var adaptiveMediaSource : UWP.AdaptiveMediaSource! {
        get { try! _IMediaSource4.get_AdaptiveMediaSourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.mediastreamsource)
    public var mediaStreamSource : MediaStreamSource! {
        get { try! _IMediaSource4.get_MediaStreamSourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.msestreamsource)
    public var mseStreamSource : MseStreamSource! {
        get { try! _IMediaSource4.get_MseStreamSourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.uri)
    public var uri : WindowsFoundation.Uri! {
        get { try! _IMediaSource4.get_UriImpl() }
    }

    private lazy var _IMediaSource5: __ABI_Windows_Media_Core.IMediaSource5! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.downloadoperation)
    public var downloadOperation : UWP.DownloadOperation! {
        get { try! _IMediaSource5.get_DownloadOperationImpl() }
    }

    deinit {
        _IMediaPlaybackSource = nil
        _IClosable = nil
        _default = nil
        _IMediaSource3 = nil
        _IMediaSource4 = nil
        _IMediaSource5 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceappserviceconnection)
public final class MediaSourceAppServiceConnection : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaSourceAppServiceConnection
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSourceAppServiceConnection
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSourceAppServiceConnection>?) -> MediaSourceAppServiceConnection? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _IMediaSourceAppServiceConnectionFactory: __ABI_Windows_Media_Core.IMediaSourceAppServiceConnectionFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSourceAppServiceConnection"))
    public init(_ appServiceConnection: UWP.AppServiceConnection!) {
        super.init(try! Self._IMediaSourceAppServiceConnectionFactory.CreateImpl(appServiceConnection))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceappserviceconnection.start)
    public func start() throws {
        try _default.StartImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceappserviceconnection.initializemediastreamsourcerequested)
    public lazy var initializeMediaStreamSourceRequested : Event<TypedEventHandler<MediaSourceAppServiceConnection?, InitializeMediaStreamSourceRequestedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_InitializeMediaStreamSourceRequestedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_InitializeMediaStreamSourceRequestedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceerror)
public final class MediaSourceError : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaSourceError
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSourceError
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSourceError>?) -> MediaSourceError? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceerror.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceopenoperationcompletedeventargs)
public final class MediaSourceOpenOperationCompletedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaSourceOpenOperationCompletedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSourceOpenOperationCompletedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSourceOpenOperationCompletedEventArgs>?) -> MediaSourceOpenOperationCompletedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceopenoperationcompletedeventargs.error)
    public var error : MediaSourceError! {
        get { try! _default.get_ErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatechangedeventargs)
public final class MediaSourceStateChangedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaSourceStateChangedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSourceStateChangedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSourceStateChangedEventArgs>?) -> MediaSourceStateChangedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatechangedeventargs.newstate)
    public var newState : MediaSourceState {
        get { try! _default.get_NewStateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatechangedeventargs.oldstate)
    public var oldState : MediaSourceState {
        get { try! _default.get_OldStateImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample)
public final class MediaStreamSample : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSample
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSample
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSample>?) -> MediaStreamSample? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _IMediaStreamSampleStatics: __ABI_Windows_Media_Core.IMediaStreamSampleStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaStreamSample"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.createfrombuffer)
    public static func createFromBuffer(_ buffer: UWP.AnyIBuffer!, _ timestamp: WindowsFoundation.TimeSpan) -> MediaStreamSample! {
        return try! _IMediaStreamSampleStatics.CreateFromBufferImpl(buffer, timestamp)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.createfromstreamasync)
    public static func createFromStreamAsync(_ stream: UWP.AnyIInputStream!, _ count: UInt32, _ timestamp: WindowsFoundation.TimeSpan) -> WindowsFoundation.AnyIAsyncOperation<MediaStreamSample?>! {
        return try! _IMediaStreamSampleStatics.CreateFromStreamAsyncImpl(stream, count, timestamp)
    }

    private static let _IMediaStreamSampleStatics2: __ABI_Windows_Media_Core.IMediaStreamSampleStatics2 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaStreamSample"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.createfromdirect3d11surface)
    public static func createFromDirect3D11Surface(_ surface: UWP.AnyIDirect3DSurface!, _ timestamp: WindowsFoundation.TimeSpan) -> MediaStreamSample! {
        return try! _IMediaStreamSampleStatics2.CreateFromDirect3D11SurfaceImpl(surface, timestamp)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.buffer)
    public var buffer : UWP.Buffer! {
        get { try! _default.get_BufferImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.decodetimestamp)
    public var decodeTimestamp : WindowsFoundation.TimeSpan {
        get { try! _default.get_DecodeTimestampImpl() }
        set { try! _default.put_DecodeTimestampImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.discontinuous)
    public var discontinuous : Bool {
        get { try! _default.get_DiscontinuousImpl() }
        set { try! _default.put_DiscontinuousImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _default.get_DurationImpl() }
        set { try! _default.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.extendedproperties)
    public var extendedProperties : MediaStreamSamplePropertySet! {
        get { try! _default.get_ExtendedPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.keyframe)
    public var keyFrame : Bool {
        get { try! _default.get_KeyFrameImpl() }
        set { try! _default.put_KeyFrameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.protection)
    public var protection : MediaStreamSampleProtectionProperties! {
        get { try! _default.get_ProtectionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.timestamp)
    public var timestamp : WindowsFoundation.TimeSpan {
        get { try! _default.get_TimestampImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.processed)
    public lazy var processed : Event<TypedEventHandler<MediaStreamSample?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ProcessedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ProcessedImpl($0)
       }
      )
    }()

    private lazy var _IMediaStreamSample2: __ABI_Windows_Media_Core.IMediaStreamSample2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.direct3d11surface)
    public var direct3D11Surface : UWP.AnyIDirect3DSurface! {
        get { try! _IMediaStreamSample2.get_Direct3D11SurfaceImpl() }
    }

    deinit {
        _default = nil
        _IMediaStreamSample2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset)
public final class MediaStreamSamplePropertySet : WinRTClass, IMap, IIterable {
    public typealias K = Foundation.UUID
    public typealias V = Any?
    public typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?
    private typealias SwiftABI = UWP.IMapUUID_Any
    private typealias CABI = __x_ABI_C__FIMap_2_GUID_IInspectable
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_C__FIMap_2_GUID_IInspectable>?) -> MediaStreamSamplePropertySet? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.lookup)
    public func lookup(_ key: Foundation.UUID) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.haskey)
    public func hasKey(_ key: Foundation.UUID) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.getview)
    public func getView() -> WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.insert)
    public func insert(_ key: Foundation.UUID, _ value: Any?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.remove)
    public func remove(_ key: Foundation.UUID) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.clear)
    public func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairUUID_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.first)
    public func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    deinit {
        _default = nil
        _IIterable = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsampleprotectionproperties)
public final class MediaStreamSampleProtectionProperties : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSampleProtectionProperties
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSampleProtectionProperties
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSampleProtectionProperties>?) -> MediaStreamSampleProtectionProperties? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource)
public final class MediaStreamSource : WinRTClass, IMediaSource {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSource
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSource
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSource>?) -> MediaStreamSource? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static let _IMediaStreamSourceFactory: __ABI_Windows_Media_Core.IMediaStreamSourceFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaStreamSource"))
    public init(_ descriptor: AnyIMediaStreamDescriptor!) {
        super.init(try! Self._IMediaStreamSourceFactory.CreateFromDescriptorImpl(descriptor))
    }

    public init(_ descriptor: AnyIMediaStreamDescriptor!, _ descriptor2: AnyIMediaStreamDescriptor!) {
        super.init(try! Self._IMediaStreamSourceFactory.CreateFromDescriptorsImpl(descriptor, descriptor2))
    }

    private lazy var _IMediaSource: __ABI_Windows_Media_Core.IMediaSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.notifyerror)
    public func notifyError(_ errorStatus: MediaStreamSourceErrorStatus) throws {
        try _default.NotifyErrorImpl(errorStatus)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.addstreamdescriptor)
    public func addStreamDescriptor(_ descriptor: AnyIMediaStreamDescriptor!) throws {
        try _default.AddStreamDescriptorImpl(descriptor)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.setbufferedrange)
    public func setBufferedRange(_ startOffset: WindowsFoundation.TimeSpan, _ endOffset: WindowsFoundation.TimeSpan) throws {
        try _default.SetBufferedRangeImpl(startOffset, endOffset)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.buffertime)
    public var bufferTime : WindowsFoundation.TimeSpan {
        get { try! _default.get_BufferTimeImpl() }
        set { try! _default.put_BufferTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.canseek)
    public var canSeek : Bool {
        get { try! _default.get_CanSeekImpl() }
        set { try! _default.put_CanSeekImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _default.get_DurationImpl() }
        set { try! _default.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.mediaprotectionmanager)
    public var mediaProtectionManager : UWP.MediaProtectionManager! {
        get { try! _default.get_MediaProtectionManagerImpl() }
        set { try! _default.put_MediaProtectionManagerImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.musicproperties)
    public var musicProperties : UWP.MusicProperties! {
        get { try! _default.get_MusicPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.thumbnail)
    public var thumbnail : UWP.AnyIRandomAccessStreamReference! {
        get { try! _default.get_ThumbnailImpl() }
        set { try! _default.put_ThumbnailImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.videoproperties)
    public var videoProperties : UWP.VideoProperties! {
        get { try! _default.get_VideoPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.closed)
    public lazy var closed : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceClosedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ClosedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ClosedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.paused)
    public lazy var paused : Event<TypedEventHandler<MediaStreamSource?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PausedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PausedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.samplerequested)
    public lazy var sampleRequested : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceSampleRequestedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_SampleRequestedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_SampleRequestedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.starting)
    public lazy var starting : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceStartingEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_StartingImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_StartingImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.switchstreamsrequested)
    public lazy var switchStreamsRequested : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceSwitchStreamsRequestedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_SwitchStreamsRequestedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_SwitchStreamsRequestedImpl($0)
       }
      )
    }()

    private lazy var _IMediaStreamSource2: __ABI_Windows_Media_Core.IMediaStreamSource2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.samplerendered)
    public lazy var sampleRendered : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceSampleRenderedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaStreamSource2 else { return .init() }
          return try! this.add_SampleRenderedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaStreamSource2.remove_SampleRenderedImpl($0)
       }
      )
    }()

    private lazy var _IMediaStreamSource3: __ABI_Windows_Media_Core.IMediaStreamSource3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.maxsupportedplaybackrate)
    public var maxSupportedPlaybackRate : Double? {
        get { try! _IMediaStreamSource3.get_MaxSupportedPlaybackRateImpl() }
        set { try! _IMediaStreamSource3.put_MaxSupportedPlaybackRateImpl(newValue) }
    }

    private lazy var _IMediaStreamSource4: __ABI_Windows_Media_Core.IMediaStreamSource4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.islive)
    public var isLive : Bool {
        get { try! _IMediaStreamSource4.get_IsLiveImpl() }
        set { try! _IMediaStreamSource4.put_IsLiveImpl(newValue) }
    }

    deinit {
        _IMediaSource = nil
        _default = nil
        _IMediaStreamSource2 = nil
        _IMediaStreamSource3 = nil
        _IMediaStreamSource4 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedeventargs)
public final class MediaStreamSourceClosedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceClosedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedEventArgs>?) -> MediaStreamSourceClosedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedeventargs.request)
    public var request : MediaStreamSourceClosedRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedrequest)
public final class MediaStreamSourceClosedRequest : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceClosedRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedRequest
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedRequest>?) -> MediaStreamSourceClosedRequest? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedrequest.reason)
    public var reason : MediaStreamSourceClosedReason {
        get { try! _default.get_ReasonImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerenderedeventargs)
public final class MediaStreamSourceSampleRenderedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRenderedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRenderedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRenderedEventArgs>?) -> MediaStreamSourceSampleRenderedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerenderedeventargs.samplelag)
    public var sampleLag : WindowsFoundation.TimeSpan {
        get { try! _default.get_SampleLagImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest)
public final class MediaStreamSourceSampleRequest : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequest
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequest>?) -> MediaStreamSourceSampleRequest? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.getdeferral)
    public func getDeferral() throws -> MediaStreamSourceSampleRequestDeferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.reportsampleprogress)
    public func reportSampleProgress(_ progress: UInt32) throws {
        try _default.ReportSampleProgressImpl(progress)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.sample)
    public var sample : MediaStreamSample! {
        get { try! _default.get_SampleImpl() }
        set { try! _default.put_SampleImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.streamdescriptor)
    public var streamDescriptor : AnyIMediaStreamDescriptor! {
        get { try! _default.get_StreamDescriptorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestdeferral)
public final class MediaStreamSourceSampleRequestDeferral : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRequestDeferral
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestDeferral
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestDeferral>?) -> MediaStreamSourceSampleRequestDeferral? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestdeferral.complete)
    public func complete() throws {
        try _default.CompleteImpl()
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestedeventargs)
public final class MediaStreamSourceSampleRequestedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRequestedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestedEventArgs>?) -> MediaStreamSourceSampleRequestedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestedeventargs.request)
    public var request : MediaStreamSourceSampleRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingeventargs)
public final class MediaStreamSourceStartingEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceStartingEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingEventArgs>?) -> MediaStreamSourceStartingEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingeventargs.request)
    public var request : MediaStreamSourceStartingRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest)
public final class MediaStreamSourceStartingRequest : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceStartingRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequest
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequest>?) -> MediaStreamSourceStartingRequest? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest.getdeferral)
    public func getDeferral() throws -> MediaStreamSourceStartingRequestDeferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest.setactualstartposition)
    public func setActualStartPosition(_ position: WindowsFoundation.TimeSpan) throws {
        try _default.SetActualStartPositionImpl(position)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest.startposition)
    public var startPosition : WindowsFoundation.TimeSpan? {
        get { try! _default.get_StartPositionImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequestdeferral)
public final class MediaStreamSourceStartingRequestDeferral : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceStartingRequestDeferral
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequestDeferral
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequestDeferral>?) -> MediaStreamSourceStartingRequestDeferral? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequestdeferral.complete)
    public func complete() throws {
        try _default.CompleteImpl()
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest)
public final class MediaStreamSourceSwitchStreamsRequest : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceSwitchStreamsRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequest
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequest>?) -> MediaStreamSourceSwitchStreamsRequest? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest.getdeferral)
    public func getDeferral() throws -> MediaStreamSourceSwitchStreamsRequestDeferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest.newstreamdescriptor)
    public var newStreamDescriptor : AnyIMediaStreamDescriptor! {
        get { try! _default.get_NewStreamDescriptorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest.oldstreamdescriptor)
    public var oldStreamDescriptor : AnyIMediaStreamDescriptor! {
        get { try! _default.get_OldStreamDescriptorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestdeferral)
public final class MediaStreamSourceSwitchStreamsRequestDeferral : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceSwitchStreamsRequestDeferral
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestDeferral
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestDeferral>?) -> MediaStreamSourceSwitchStreamsRequestDeferral? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestdeferral.complete)
    public func complete() throws {
        try _default.CompleteImpl()
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestedeventargs)
public final class MediaStreamSourceSwitchStreamsRequestedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamSourceSwitchStreamsRequestedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestedEventArgs>?) -> MediaStreamSourceSwitchStreamsRequestedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestedeventargs.request)
    public var request : MediaStreamSourceSwitchStreamsRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer)
public final class MseSourceBuffer : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMseSourceBuffer
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMseSourceBuffer
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMseSourceBuffer>?) -> MseSourceBuffer? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendbuffer)
    public func appendBuffer(_ buffer: UWP.AnyIBuffer!) throws {
        try _default.AppendBufferImpl(buffer)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendstream)
    public func appendStream(_ stream: UWP.AnyIInputStream!) throws {
        try _default.AppendStreamImpl(stream)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendstream)
    public func appendStream(_ stream: UWP.AnyIInputStream!, _ maxSize: UInt64) throws {
        try _default.AppendStreamMaxSizeImpl(stream, maxSize)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.abort)
    public func abort() throws {
        try _default.AbortImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.remove)
    public func remove(_ start: WindowsFoundation.TimeSpan, _ end: WindowsFoundation.TimeSpan?) throws {
        try _default.RemoveImpl(start, end)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendwindowend)
    public var appendWindowEnd : WindowsFoundation.TimeSpan? {
        get { try! _default.get_AppendWindowEndImpl() }
        set { try! _default.put_AppendWindowEndImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendwindowstart)
    public var appendWindowStart : WindowsFoundation.TimeSpan {
        get { try! _default.get_AppendWindowStartImpl() }
        set { try! _default.put_AppendWindowStartImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.buffered)
    public var buffered : WindowsFoundation.AnyIVectorView<MseTimeRange>! {
        get { try! _default.get_BufferedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.isupdating)
    public var isUpdating : Bool {
        get { try! _default.get_IsUpdatingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.mode)
    public var mode : MseAppendMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.timestampoffset)
    public var timestampOffset : WindowsFoundation.TimeSpan {
        get { try! _default.get_TimestampOffsetImpl() }
        set { try! _default.put_TimestampOffsetImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.aborted)
    public lazy var aborted : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_AbortedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_AbortedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.erroroccurred)
    public lazy var errorOccurred : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ErrorOccurredImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ErrorOccurredImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.updateended)
    public lazy var updateEnded : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_UpdateEndedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_UpdateEndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.updatestarting)
    public lazy var updateStarting : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_UpdateStartingImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_UpdateStartingImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.updated)
    public lazy var updated : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_UpdatedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_UpdatedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist)
public final class MseSourceBufferList : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMseSourceBufferList
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMseSourceBufferList
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMseSourceBufferList>?) -> MseSourceBufferList? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist.buffers)
    public var buffers : WindowsFoundation.AnyIVectorView<MseSourceBuffer?>! {
        get { try! _default.get_BuffersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist.sourcebufferadded)
    public lazy var sourceBufferAdded : Event<TypedEventHandler<MseSourceBufferList?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_SourceBufferAddedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_SourceBufferAddedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist.sourcebufferremoved)
    public lazy var sourceBufferRemoved : Event<TypedEventHandler<MseSourceBufferList?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_SourceBufferRemovedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_SourceBufferRemovedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource)
public final class MseStreamSource : WinRTClass, IMediaSource {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMseStreamSource
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMseStreamSource
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMseStreamSource>?) -> MseStreamSource? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.MseStreamSource")))
    }

    private static let _IMseStreamSourceStatics: __ABI_Windows_Media_Core.IMseStreamSourceStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.MseStreamSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.iscontenttypesupported)
    public static func isContentTypeSupported(_ contentType: String) -> Bool {
        return try! _IMseStreamSourceStatics.IsContentTypeSupportedImpl(contentType)
    }

    private lazy var _IMediaSource: __ABI_Windows_Media_Core.IMediaSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.addsourcebuffer)
    public func addSourceBuffer(_ mimeType: String) throws -> MseSourceBuffer! {
        try _default.AddSourceBufferImpl(mimeType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.removesourcebuffer)
    public func removeSourceBuffer(_ buffer: MseSourceBuffer!) throws {
        try _default.RemoveSourceBufferImpl(buffer)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.endofstream)
    public func endOfStream(_ status: MseEndOfStreamStatus) throws {
        try _default.EndOfStreamImpl(status)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.activesourcebuffers)
    public var activeSourceBuffers : MseSourceBufferList! {
        get { try! _default.get_ActiveSourceBuffersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.duration)
    public var duration : WindowsFoundation.TimeSpan? {
        get { try! _default.get_DurationImpl() }
        set { try! _default.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.readystate)
    public var readyState : MseReadyState {
        get { try! _default.get_ReadyStateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.sourcebuffers)
    public var sourceBuffers : MseSourceBufferList! {
        get { try! _default.get_SourceBuffersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.closed)
    public lazy var closed : Event<TypedEventHandler<MseStreamSource?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ClosedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ClosedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.ended)
    public lazy var ended : Event<TypedEventHandler<MseStreamSource?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_EndedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_EndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.opened)
    public lazy var opened : Event<TypedEventHandler<MseStreamSource?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_OpenedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_OpenedImpl($0)
       }
      )
    }()

    private lazy var _IMseStreamSource2: __ABI_Windows_Media_Core.IMseStreamSource2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.liveseekablerange)
    public var liveSeekableRange : MseTimeRange? {
        get { try! _IMseStreamSource2.get_LiveSeekableRangeImpl() }
        set { try! _IMseStreamSource2.put_LiveSeekableRangeImpl(newValue) }
    }

    deinit {
        _IMediaSource = nil
        _default = nil
        _IMseStreamSource2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffect)
public final class SceneAnalysisEffect : WinRTClass, UWP.IMediaExtension {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ISceneAnalysisEffect
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CISceneAnalysisEffect
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CISceneAnalysisEffect>?) -> SceneAnalysisEffect? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IMediaExtension: __ABI_Windows_Media.IMediaExtension! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffect.setproperties)
    public func setProperties(_ configuration: WindowsFoundation.AnyIPropertySet!) throws {
        try _IMediaExtension.SetPropertiesImpl(configuration)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffect.desiredanalysisinterval)
    public var desiredAnalysisInterval : WindowsFoundation.TimeSpan {
        get { try! _default.get_DesiredAnalysisIntervalImpl() }
        set { try! _default.put_DesiredAnalysisIntervalImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffect.highdynamicrangeanalyzer)
    public var highDynamicRangeAnalyzer : HighDynamicRangeControl! {
        get { try! _default.get_HighDynamicRangeAnalyzerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffect.sceneanalyzed)
    public lazy var sceneAnalyzed : Event<TypedEventHandler<SceneAnalysisEffect?, SceneAnalyzedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_SceneAnalyzedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_SceneAnalyzedImpl($0)
       }
      )
    }()

    deinit {
        _IMediaExtension = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectdefinition)
public final class SceneAnalysisEffectDefinition : WinRTClass, UWP.IVideoEffectDefinition {
    private typealias SwiftABI = __ABI_Windows_Media_Effects.IVideoEffectDefinition
    private typealias CABI = __x_ABI_CWindows_CMedia_CEffects_CIVideoEffectDefinition
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CEffects_CIVideoEffectDefinition>?) -> SceneAnalysisEffectDefinition? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.SceneAnalysisEffectDefinition")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectdefinition.activatableclassid)
    public var activatableClassId : String {
        get { try! _default.get_ActivatableClassIdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectdefinition.properties)
    public var properties : WindowsFoundation.AnyIPropertySet! {
        get { try! _default.get_PropertiesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe)
public final class SceneAnalysisEffectFrame : WinRTClass, WindowsFoundation.IClosable, UWP.IMediaFrame {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ISceneAnalysisEffectFrame
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CISceneAnalysisEffectFrame
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CISceneAnalysisEffectFrame>?) -> SceneAnalysisEffectFrame? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.close)
    public func close() throws {
        try _IClosable.CloseImpl()
    }

    private lazy var _IMediaFrame: __ABI_Windows_Media.IMediaFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.duration)
    public var duration : WindowsFoundation.TimeSpan? {
        get { try! _IMediaFrame.get_DurationImpl() }
        set { try! _IMediaFrame.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.extendedproperties)
    public var extendedProperties : WindowsFoundation.AnyIPropertySet! {
        get { try! _IMediaFrame.get_ExtendedPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.isdiscontinuous)
    public var isDiscontinuous : Bool {
        get { try! _IMediaFrame.get_IsDiscontinuousImpl() }
        set { try! _IMediaFrame.put_IsDiscontinuousImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.isreadonly)
    public var isReadOnly : Bool {
        get { try! _IMediaFrame.get_IsReadOnlyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.relativetime)
    public var relativeTime : WindowsFoundation.TimeSpan? {
        get { try! _IMediaFrame.get_RelativeTimeImpl() }
        set { try! _IMediaFrame.put_RelativeTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.systemrelativetime)
    public var systemRelativeTime : WindowsFoundation.TimeSpan? {
        get { try! _IMediaFrame.get_SystemRelativeTimeImpl() }
        set { try! _IMediaFrame.put_SystemRelativeTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.type)
    public var type : String {
        get { try! _IMediaFrame.get_TypeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.framecontrolvalues)
    public var frameControlValues : UWP.CapturedFrameControlValues! {
        get { try! _default.get_FrameControlValuesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.highdynamicrange)
    public var highDynamicRange : HighDynamicRangeOutput! {
        get { try! _default.get_HighDynamicRangeImpl() }
    }

    private lazy var _ISceneAnalysisEffectFrame2: __ABI_Windows_Media_Core.ISceneAnalysisEffectFrame2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalysiseffectframe.analysisrecommendation)
    public var analysisRecommendation : SceneAnalysisRecommendation {
        get { try! _ISceneAnalysisEffectFrame2.get_AnalysisRecommendationImpl() }
    }

    deinit {
        _IClosable = nil
        _IMediaFrame = nil
        _default = nil
        _ISceneAnalysisEffectFrame2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalyzedeventargs)
public final class SceneAnalyzedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ISceneAnalyzedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CISceneAnalyzedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CISceneAnalyzedEventArgs>?) -> SceneAnalyzedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.sceneanalyzedeventargs.resultframe)
    public var resultFrame : SceneAnalysisEffectFrame! {
        get { try! _default.get_ResultFrameImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.speechcue)
public final class SpeechCue : WinRTClass, IMediaCue {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ISpeechCue
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CISpeechCue
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CISpeechCue>?) -> SpeechCue? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.SpeechCue")))
    }

    private lazy var _IMediaCue: __ABI_Windows_Media_Core.IMediaCue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.speechcue.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_DurationImpl() }
        set { try! _IMediaCue.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.speechcue.id)
    public var id : String {
        get { try! _IMediaCue.get_IdImpl() }
        set { try! _IMediaCue.put_IdImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.speechcue.starttime)
    public var startTime : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_StartTimeImpl() }
        set { try! _IMediaCue.put_StartTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.speechcue.endpositionininput)
    public var endPositionInInput : Int32? {
        get { try! _default.get_EndPositionInInputImpl() }
        set { try! _default.put_EndPositionInInputImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.speechcue.startpositionininput)
    public var startPositionInInput : Int32? {
        get { try! _default.get_StartPositionInInputImpl() }
        set { try! _default.put_StartPositionInInputImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.speechcue.text)
    public var text : String {
        get { try! _default.get_TextImpl() }
        set { try! _default.put_TextImpl(newValue) }
    }

    deinit {
        _IMediaCue = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatastreamdescriptor)
public final class TimedMetadataStreamDescriptor : WinRTClass, IMediaStreamDescriptor, IMediaStreamDescriptor2 {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaStreamDescriptor
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamDescriptor
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamDescriptor>?) -> TimedMetadataStreamDescriptor? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static let _ITimedMetadataStreamDescriptorFactory: __ABI_Windows_Media_Core.ITimedMetadataStreamDescriptorFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.TimedMetadataStreamDescriptor"))
    public init(_ encodingProperties: UWP.TimedMetadataEncodingProperties!) {
        super.init(try! Self._ITimedMetadataStreamDescriptorFactory.CreateImpl(encodingProperties))
    }

    private lazy var _ITimedMetadataStreamDescriptor: __ABI_Windows_Media_Core.ITimedMetadataStreamDescriptor! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatastreamdescriptor.copy)
    public func copy() throws -> TimedMetadataStreamDescriptor! {
        try _ITimedMetadataStreamDescriptor.CopyImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatastreamdescriptor.encodingproperties)
    public var encodingProperties : UWP.TimedMetadataEncodingProperties! {
        get { try! _ITimedMetadataStreamDescriptor.get_EncodingPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatastreamdescriptor.isselected)
    public var isSelected : Bool {
        get { try! _default.get_IsSelectedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatastreamdescriptor.language)
    public var language : String {
        get { try! _default.get_LanguageImpl() }
        set { try! _default.put_LanguageImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatastreamdescriptor.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
        set { try! _default.put_NameImpl(newValue) }
    }

    private lazy var _IMediaStreamDescriptor2: __ABI_Windows_Media_Core.IMediaStreamDescriptor2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatastreamdescriptor.label)
    public var label : String {
        get { try! _IMediaStreamDescriptor2.get_LabelImpl() }
        set { try! _IMediaStreamDescriptor2.put_LabelImpl(newValue) }
    }

    deinit {
        _ITimedMetadataStreamDescriptor = nil
        _default = nil
        _IMediaStreamDescriptor2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack)
public final class TimedMetadataTrack : WinRTClass, IMediaTrack {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedMetadataTrack
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrack
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrack>?) -> TimedMetadataTrack? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static let _ITimedMetadataTrackFactory: __ABI_Windows_Media_Core.ITimedMetadataTrackFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.TimedMetadataTrack"))
    public init(_ id: String, _ language: String, _ kind: TimedMetadataKind) {
        super.init(try! Self._ITimedMetadataTrackFactory.CreateImpl(id, language, kind))
    }

    private lazy var _IMediaTrack: __ABI_Windows_Media_Core.IMediaTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.id)
    public var id : String {
        get { try! _IMediaTrack.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.label)
    public var label : String {
        get { try! _IMediaTrack.get_LabelImpl() }
        set { try! _IMediaTrack.put_LabelImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.language)
    public var language : String {
        get { try! _IMediaTrack.get_LanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.trackkind)
    public var trackKind : MediaTrackKind {
        get { try! _IMediaTrack.get_TrackKindImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.addcue)
    public func addCue(_ cue: AnyIMediaCue!) throws {
        try _default.AddCueImpl(cue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.removecue)
    public func removeCue(_ cue: AnyIMediaCue!) throws {
        try _default.RemoveCueImpl(cue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.activecues)
    public var activeCues : WindowsFoundation.AnyIVectorView<AnyIMediaCue?>! {
        get { try! _default.get_ActiveCuesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.cues)
    public var cues : WindowsFoundation.AnyIVectorView<AnyIMediaCue?>! {
        get { try! _default.get_CuesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.dispatchtype)
    public var dispatchType : String {
        get { try! _default.get_DispatchTypeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.timedmetadatakind)
    public var timedMetadataKind : TimedMetadataKind {
        get { try! _default.get_TimedMetadataKindImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.cueentered)
    public lazy var cueEntered : Event<TypedEventHandler<TimedMetadataTrack?, MediaCueEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_CueEnteredImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_CueEnteredImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.cueexited)
    public lazy var cueExited : Event<TypedEventHandler<TimedMetadataTrack?, MediaCueEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_CueExitedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_CueExitedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.trackfailed)
    public lazy var trackFailed : Event<TypedEventHandler<TimedMetadataTrack?, TimedMetadataTrackFailedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_TrackFailedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_TrackFailedImpl($0)
       }
      )
    }()

    private lazy var _ITimedMetadataTrack2: __ABI_Windows_Media_Core.ITimedMetadataTrack2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.name)
    public var name : String {
        get { try! _ITimedMetadataTrack2.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.playbackitem)
    public var playbackItem : UWP.MediaPlaybackItem! {
        get { try! _ITimedMetadataTrack2.get_PlaybackItemImpl() }
    }

    deinit {
        _IMediaTrack = nil
        _default = nil
        _ITimedMetadataTrack2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerror)
public final class TimedMetadataTrackError : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedMetadataTrackError
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackError
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackError>?) -> TimedMetadataTrackError? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerror.errorcode)
    public var errorCode : TimedMetadataTrackErrorCode {
        get { try! _default.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerror.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackfailedeventargs)
public final class TimedMetadataTrackFailedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedMetadataTrackFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackFailedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackFailedEventArgs>?) -> TimedMetadataTrackFailedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackfailedeventargs.error)
    public var error : TimedMetadataTrackError! {
        get { try! _default.get_ErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextcue)
public final class TimedTextCue : WinRTClass, IMediaCue {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedTextCue
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextCue
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextCue>?) -> TimedTextCue? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.TimedTextCue")))
    }

    private lazy var _IMediaCue: __ABI_Windows_Media_Core.IMediaCue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextcue.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_DurationImpl() }
        set { try! _IMediaCue.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextcue.id)
    public var id : String {
        get { try! _IMediaCue.get_IdImpl() }
        set { try! _IMediaCue.put_IdImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextcue.starttime)
    public var startTime : WindowsFoundation.TimeSpan {
        get { try! _IMediaCue.get_StartTimeImpl() }
        set { try! _IMediaCue.put_StartTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextcue.cueregion)
    public var cueRegion : TimedTextRegion! {
        get { try! _default.get_CueRegionImpl() }
        set { try! _default.put_CueRegionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextcue.cuestyle)
    public var cueStyle : TimedTextStyle! {
        get { try! _default.get_CueStyleImpl() }
        set { try! _default.put_CueStyleImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextcue.lines)
    public var lines : WindowsFoundation.AnyIVector<TimedTextLine?>! {
        get { try! _default.get_LinesImpl() }
    }

    deinit {
        _IMediaCue = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextline)
public final class TimedTextLine : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedTextLine
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextLine
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextLine>?) -> TimedTextLine? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.TimedTextLine")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextline.subformats)
    public var subformats : WindowsFoundation.AnyIVector<TimedTextSubformat?>! {
        get { try! _default.get_SubformatsImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextline.text)
    public var text : String {
        get { try! _default.get_TextImpl() }
        set { try! _default.put_TextImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion)
public final class TimedTextRegion : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedTextRegion
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextRegion
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextRegion>?) -> TimedTextRegion? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.TimedTextRegion")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.background)
    public var background : UWP.Color {
        get { try! _default.get_BackgroundImpl() }
        set { try! _default.put_BackgroundImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.displayalignment)
    public var displayAlignment : TimedTextDisplayAlignment {
        get { try! _default.get_DisplayAlignmentImpl() }
        set { try! _default.put_DisplayAlignmentImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.extent)
    public var extent : TimedTextSize {
        get { try! _default.get_ExtentImpl() }
        set { try! _default.put_ExtentImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.isoverflowclipped)
    public var isOverflowClipped : Bool {
        get { try! _default.get_IsOverflowClippedImpl() }
        set { try! _default.put_IsOverflowClippedImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.lineheight)
    public var lineHeight : TimedTextDouble {
        get { try! _default.get_LineHeightImpl() }
        set { try! _default.put_LineHeightImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
        set { try! _default.put_NameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.padding)
    public var padding : TimedTextPadding {
        get { try! _default.get_PaddingImpl() }
        set { try! _default.put_PaddingImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.position)
    public var position : TimedTextPoint {
        get { try! _default.get_PositionImpl() }
        set { try! _default.put_PositionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.scrollmode)
    public var scrollMode : TimedTextScrollMode {
        get { try! _default.get_ScrollModeImpl() }
        set { try! _default.put_ScrollModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.textwrapping)
    public var textWrapping : TimedTextWrapping {
        get { try! _default.get_TextWrappingImpl() }
        set { try! _default.put_TextWrappingImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.writingmode)
    public var writingMode : TimedTextWritingMode {
        get { try! _default.get_WritingModeImpl() }
        set { try! _default.put_WritingModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextregion.zindex)
    public var zindex : Int32 {
        get { try! _default.get_ZIndexImpl() }
        set { try! _default.put_ZIndexImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource)
public final class TimedTextSource : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedTextSource
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextSource
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextSource>?) -> TimedTextSource? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _ITimedTextSourceStatics: __ABI_Windows_Media_Core.ITimedTextSourceStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.TimedTextSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstream)
    public static func createFromStream(_ stream: UWP.AnyIRandomAccessStream!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromStreamImpl(stream)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuri)
    public static func createFromUri(_ uri: WindowsFoundation.Uri!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromUriImpl(uri)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstream)
    public static func createFromStream(_ stream: UWP.AnyIRandomAccessStream!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromStreamWithLanguageImpl(stream, defaultLanguage)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuri)
    public static func createFromUri(_ uri: WindowsFoundation.Uri!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromUriWithLanguageImpl(uri, defaultLanguage)
    }

    private static let _ITimedTextSourceStatics2: __ABI_Windows_Media_Core.ITimedTextSourceStatics2 = try! RoGetActivationFactory(HString("Windows.Media.Core.TimedTextSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstreamwithindex)
    public static func createFromStreamWithIndex(_ stream: UWP.AnyIRandomAccessStream!, _ indexStream: UWP.AnyIRandomAccessStream!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromStreamWithIndexImpl(stream, indexStream)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuriwithindex)
    public static func createFromUriWithIndex(_ uri: WindowsFoundation.Uri!, _ indexUri: WindowsFoundation.Uri!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromUriWithIndexImpl(uri, indexUri)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstreamwithindex)
    public static func createFromStreamWithIndex(_ stream: UWP.AnyIRandomAccessStream!, _ indexStream: UWP.AnyIRandomAccessStream!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromStreamWithIndexAndLanguageImpl(stream, indexStream, defaultLanguage)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuriwithindex)
    public static func createFromUriWithIndex(_ uri: WindowsFoundation.Uri!, _ indexUri: WindowsFoundation.Uri!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromUriWithIndexAndLanguageImpl(uri, indexUri, defaultLanguage)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.resolved)
    public lazy var resolved : Event<TypedEventHandler<TimedTextSource?, TimedTextSourceResolveResultEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ResolvedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ResolvedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsourceresolveresulteventargs)
public final class TimedTextSourceResolveResultEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedTextSourceResolveResultEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextSourceResolveResultEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextSourceResolveResultEventArgs>?) -> TimedTextSourceResolveResultEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsourceresolveresulteventargs.error)
    public var error : TimedMetadataTrackError! {
        get { try! _default.get_ErrorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsourceresolveresulteventargs.tracks)
    public var tracks : WindowsFoundation.AnyIVectorView<TimedMetadataTrack?>! {
        get { try! _default.get_TracksImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle)
public final class TimedTextStyle : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedTextStyle
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextStyle
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextStyle>?) -> TimedTextStyle? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.TimedTextStyle")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.background)
    public var background : UWP.Color {
        get { try! _default.get_BackgroundImpl() }
        set { try! _default.put_BackgroundImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.flowdirection)
    public var flowDirection : TimedTextFlowDirection {
        get { try! _default.get_FlowDirectionImpl() }
        set { try! _default.put_FlowDirectionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.fontfamily)
    public var fontFamily : String {
        get { try! _default.get_FontFamilyImpl() }
        set { try! _default.put_FontFamilyImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.fontsize)
    public var fontSize : TimedTextDouble {
        get { try! _default.get_FontSizeImpl() }
        set { try! _default.put_FontSizeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.fontweight)
    public var fontWeight : TimedTextWeight {
        get { try! _default.get_FontWeightImpl() }
        set { try! _default.put_FontWeightImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.foreground)
    public var foreground : UWP.Color {
        get { try! _default.get_ForegroundImpl() }
        set { try! _default.put_ForegroundImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.isbackgroundalwaysshown)
    public var isBackgroundAlwaysShown : Bool {
        get { try! _default.get_IsBackgroundAlwaysShownImpl() }
        set { try! _default.put_IsBackgroundAlwaysShownImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.linealignment)
    public var lineAlignment : TimedTextLineAlignment {
        get { try! _default.get_LineAlignmentImpl() }
        set { try! _default.put_LineAlignmentImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
        set { try! _default.put_NameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.outlinecolor)
    public var outlineColor : UWP.Color {
        get { try! _default.get_OutlineColorImpl() }
        set { try! _default.put_OutlineColorImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.outlineradius)
    public var outlineRadius : TimedTextDouble {
        get { try! _default.get_OutlineRadiusImpl() }
        set { try! _default.put_OutlineRadiusImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.outlinethickness)
    public var outlineThickness : TimedTextDouble {
        get { try! _default.get_OutlineThicknessImpl() }
        set { try! _default.put_OutlineThicknessImpl(newValue) }
    }

    private lazy var _ITimedTextStyle2: __ABI_Windows_Media_Core.ITimedTextStyle2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.fontstyle)
    public var fontStyle : TimedTextFontStyle {
        get { try! _ITimedTextStyle2.get_FontStyleImpl() }
        set { try! _ITimedTextStyle2.put_FontStyleImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.islinethroughenabled)
    public var isLineThroughEnabled : Bool {
        get { try! _ITimedTextStyle2.get_IsLineThroughEnabledImpl() }
        set { try! _ITimedTextStyle2.put_IsLineThroughEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.isoverlineenabled)
    public var isOverlineEnabled : Bool {
        get { try! _ITimedTextStyle2.get_IsOverlineEnabledImpl() }
        set { try! _ITimedTextStyle2.put_IsOverlineEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextstyle.isunderlineenabled)
    public var isUnderlineEnabled : Bool {
        get { try! _ITimedTextStyle2.get_IsUnderlineEnabledImpl() }
        set { try! _ITimedTextStyle2.put_IsUnderlineEnabledImpl(newValue) }
    }

    deinit {
        _default = nil
        _ITimedTextStyle2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsubformat)
public final class TimedTextSubformat : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.ITimedTextSubformat
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextSubformat
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextSubformat>?) -> TimedTextSubformat? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.TimedTextSubformat")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsubformat.length)
    public var length : Int32 {
        get { try! _default.get_LengthImpl() }
        set { try! _default.put_LengthImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsubformat.startindex)
    public var startIndex : Int32 {
        get { try! _default.get_StartIndexImpl() }
        set { try! _default.put_StartIndexImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsubformat.subformatstyle)
    public var subformatStyle : TimedTextStyle! {
        get { try! _default.get_SubformatStyleImpl() }
        set { try! _default.put_SubformatStyleImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffect)
public final class VideoStabilizationEffect : WinRTClass, UWP.IMediaExtension {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IVideoStabilizationEffect
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIVideoStabilizationEffect
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIVideoStabilizationEffect>?) -> VideoStabilizationEffect? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IMediaExtension: __ABI_Windows_Media.IMediaExtension! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffect.setproperties)
    public func setProperties(_ configuration: WindowsFoundation.AnyIPropertySet!) throws {
        try _IMediaExtension.SetPropertiesImpl(configuration)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffect.getrecommendedstreamconfiguration)
    public func getRecommendedStreamConfiguration(_ controller: UWP.VideoDeviceController!, _ desiredProperties: UWP.VideoEncodingProperties!) throws -> UWP.VideoStreamConfiguration! {
        try _default.GetRecommendedStreamConfigurationImpl(controller, desiredProperties)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffect.enabled)
    public var enabled : Bool {
        get { try! _default.get_EnabledImpl() }
        set { try! _default.put_EnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffect.enabledchanged)
    public lazy var enabledChanged : Event<TypedEventHandler<VideoStabilizationEffect?, VideoStabilizationEffectEnabledChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_EnabledChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_EnabledChangedImpl($0)
       }
      )
    }()

    deinit {
        _IMediaExtension = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffectdefinition)
public final class VideoStabilizationEffectDefinition : WinRTClass, UWP.IVideoEffectDefinition {
    private typealias SwiftABI = __ABI_Windows_Media_Effects.IVideoEffectDefinition
    private typealias CABI = __x_ABI_CWindows_CMedia_CEffects_CIVideoEffectDefinition
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CEffects_CIVideoEffectDefinition>?) -> VideoStabilizationEffectDefinition? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.VideoStabilizationEffectDefinition")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffectdefinition.activatableclassid)
    public var activatableClassId : String {
        get { try! _default.get_ActivatableClassIdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffectdefinition.properties)
    public var properties : WindowsFoundation.AnyIPropertySet! {
        get { try! _default.get_PropertiesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffectenabledchangedeventargs)
public final class VideoStabilizationEffectEnabledChangedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IVideoStabilizationEffectEnabledChangedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIVideoStabilizationEffectEnabledChangedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIVideoStabilizationEffectEnabledChangedEventArgs>?) -> VideoStabilizationEffectEnabledChangedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostabilizationeffectenabledchangedeventargs.reason)
    public var reason : VideoStabilizationEffectEnabledChangedReason {
        get { try! _default.get_ReasonImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostreamdescriptor)
public final class VideoStreamDescriptor : WinRTClass, IMediaStreamDescriptor, IMediaStreamDescriptor2 {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IVideoStreamDescriptor
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIVideoStreamDescriptor
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIVideoStreamDescriptor>?) -> VideoStreamDescriptor? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static let _IVideoStreamDescriptorFactory: __ABI_Windows_Media_Core.IVideoStreamDescriptorFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.VideoStreamDescriptor"))
    public init(_ encodingProperties: UWP.VideoEncodingProperties!) {
        super.init(try! Self._IVideoStreamDescriptorFactory.CreateImpl(encodingProperties))
    }

    private lazy var _IMediaStreamDescriptor: __ABI_Windows_Media_Core.IMediaStreamDescriptor! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostreamdescriptor.isselected)
    public var isSelected : Bool {
        get { try! _IMediaStreamDescriptor.get_IsSelectedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostreamdescriptor.language)
    public var language : String {
        get { try! _IMediaStreamDescriptor.get_LanguageImpl() }
        set { try! _IMediaStreamDescriptor.put_LanguageImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostreamdescriptor.name)
    public var name : String {
        get { try! _IMediaStreamDescriptor.get_NameImpl() }
        set { try! _IMediaStreamDescriptor.put_NameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostreamdescriptor.encodingproperties)
    public var encodingProperties : UWP.VideoEncodingProperties! {
        get { try! _default.get_EncodingPropertiesImpl() }
    }

    private lazy var _IMediaStreamDescriptor2: __ABI_Windows_Media_Core.IMediaStreamDescriptor2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostreamdescriptor.label)
    public var label : String {
        get { try! _IMediaStreamDescriptor2.get_LabelImpl() }
        set { try! _IMediaStreamDescriptor2.put_LabelImpl(newValue) }
    }

    private lazy var _IVideoStreamDescriptor2: __ABI_Windows_Media_Core.IVideoStreamDescriptor2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videostreamdescriptor.copy)
    public func copy() throws -> VideoStreamDescriptor! {
        try _IVideoStreamDescriptor2.CopyImpl()
    }

    deinit {
        _IMediaStreamDescriptor = nil
        _default = nil
        _IMediaStreamDescriptor2 = nil
        _IVideoStreamDescriptor2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack)
public final class VideoTrack : WinRTClass, IMediaTrack {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IMediaTrack
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaTrack
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaTrack>?) -> VideoTrack? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.id)
    public var id : String {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.label)
    public var label : String {
        get { try! _default.get_LabelImpl() }
        set { try! _default.put_LabelImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.language)
    public var language : String {
        get { try! _default.get_LanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.trackkind)
    public var trackKind : MediaTrackKind {
        get { try! _default.get_TrackKindImpl() }
    }

    private lazy var _IVideoTrack: __ABI_Windows_Media_Core.IVideoTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.getencodingproperties)
    public func getEncodingProperties() throws -> UWP.VideoEncodingProperties! {
        try _IVideoTrack.GetEncodingPropertiesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.name)
    public var name : String {
        get { try! _IVideoTrack.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.playbackitem)
    public var playbackItem : UWP.MediaPlaybackItem! {
        get { try! _IVideoTrack.get_PlaybackItemImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.supportinfo)
    public var supportInfo : VideoTrackSupportInfo! {
        get { try! _IVideoTrack.get_SupportInfoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.openfailed)
    public lazy var openFailed : Event<TypedEventHandler<VideoTrack?, VideoTrackOpenFailedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IVideoTrack else { return .init() }
          return try! this.add_OpenFailedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IVideoTrack.remove_OpenFailedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
        _IVideoTrack = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrackopenfailedeventargs)
public final class VideoTrackOpenFailedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IVideoTrackOpenFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIVideoTrackOpenFailedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIVideoTrackOpenFailedEventArgs>?) -> VideoTrackOpenFailedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrackopenfailedeventargs.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotracksupportinfo)
public final class VideoTrackSupportInfo : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Core.IVideoTrackSupportInfo
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIVideoTrackSupportInfo
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIVideoTrackSupportInfo>?) -> VideoTrackSupportInfo? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotracksupportinfo.decoderstatus)
    public var decoderStatus : MediaDecoderStatus {
        get { try! _default.get_DecoderStatusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotracksupportinfo.mediasourcestatus)
    public var mediaSourceStatus : MediaSourceStatus {
        get { try! _default.get_MediaSourceStatusImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msetimerange)
public struct MseTimeRange: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msetimerange.start)
    public var start: WindowsFoundation.TimeSpan = .init()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msetimerange.end)
    public var end: WindowsFoundation.TimeSpan = .init()
    public init() {}
    public init(start: WindowsFoundation.TimeSpan, end: WindowsFoundation.TimeSpan) {
        self.start = start
        self.end = end
    }
    public static func from(abi: __x_ABI_CWindows_CMedia_CCore_CMseTimeRange) -> MseTimeRange {
        .init(start: .from(abi: abi.Start), end: .from(abi: abi.End))
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextdouble)
public struct TimedTextDouble: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextdouble.value)
    public var value: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextdouble.unit)
    public var unit: TimedTextUnit = .init(0)
    public init() {}
    public init(value: Double, unit: TimedTextUnit) {
        self.value = value
        self.unit = unit
    }
    public static func from(abi: __x_ABI_CWindows_CMedia_CCore_CTimedTextDouble) -> TimedTextDouble {
        .init(value: abi.Value, unit: abi.Unit)
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpadding)
public struct TimedTextPadding: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpadding.before)
    public var before: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpadding.after)
    public var after: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpadding.start)
    public var start: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpadding.end)
    public var end: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpadding.unit)
    public var unit: TimedTextUnit = .init(0)
    public init() {}
    public init(before: Double, after: Double, start: Double, end: Double, unit: TimedTextUnit) {
        self.before = before
        self.after = after
        self.start = start
        self.end = end
        self.unit = unit
    }
    public static func from(abi: __x_ABI_CWindows_CMedia_CCore_CTimedTextPadding) -> TimedTextPadding {
        .init(before: abi.Before, after: abi.After, start: abi.Start, end: abi.End, unit: abi.Unit)
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpoint)
public struct TimedTextPoint: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpoint.x)
    public var x: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpoint.y)
    public var y: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextpoint.unit)
    public var unit: TimedTextUnit = .init(0)
    public init() {}
    public init(x: Double, y: Double, unit: TimedTextUnit) {
        self.x = x
        self.y = y
        self.unit = unit
    }
    public static func from(abi: __x_ABI_CWindows_CMedia_CCore_CTimedTextPoint) -> TimedTextPoint {
        .init(x: abi.X, y: abi.Y, unit: abi.Unit)
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsize)
public struct TimedTextSize: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsize.height)
    public var height: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsize.width)
    public var width: Double = 0.0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsize.unit)
    public var unit: TimedTextUnit = .init(0)
    public init() {}
    public init(height: Double, width: Double, unit: TimedTextUnit) {
        self.height = height
        self.width = width
        self.unit = unit
    }
    public static func from(abi: __x_ABI_CWindows_CMedia_CCore_CTimedTextSize) -> TimedTextSize {
        .init(height: abi.Height, width: abi.Width, unit: abi.Unit)
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue)
public protocol IMediaCue : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue.duration)
    var duration: WindowsFoundation.TimeSpan { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue.id)
    var id: String { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue.starttime)
    var startTime: WindowsFoundation.TimeSpan { get set }
}

extension IMediaCue {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaCueWrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.IMediaCueWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIMediaCue = any IMediaCue

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediasource)
public protocol IMediaSource : WinRTInterface {
}

extension IMediaSource {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaSourceWrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.IMediaSourceWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIMediaSource = any IMediaSource

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor)
public protocol IMediaStreamDescriptor : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor.isselected)
    var isSelected: Bool { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor.language)
    var language: String { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor.name)
    var name: String { get set }
}

extension IMediaStreamDescriptor {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaStreamDescriptorWrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.IMediaStreamDescriptorWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIMediaStreamDescriptor = any IMediaStreamDescriptor

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor2)
public protocol IMediaStreamDescriptor2 : IMediaStreamDescriptor {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor2.label)
    var label: String { get set }
}

extension IMediaStreamDescriptor2 {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaStreamDescriptor2Wrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.IMediaStreamDescriptor2Wrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Media_Core.IMediaStreamDescriptorWrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.IMediaStreamDescriptorWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIMediaStreamDescriptor2 = any IMediaStreamDescriptor2

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack)
public protocol IMediaTrack : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.id)
    var id: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.label)
    var label: String { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.language)
    var language: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.trackkind)
    var trackKind: UWP.MediaTrackKind { get }
}

extension IMediaTrack {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaTrackWrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.IMediaTrackWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIMediaTrack = any IMediaTrack

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.isingleselectmediatracklist)
public protocol ISingleSelectMediaTrackList : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.isingleselectmediatracklist.selectedindex)
    var selectedIndex: Int32 { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.isingleselectmediatracklist.selectedindexchanged)
    var selectedIndexChanged: Event<TypedEventHandler<ISingleSelectMediaTrackList?, Any?>> { get }
}

extension ISingleSelectMediaTrackList {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.ISingleSelectMediaTrackListWrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.ISingleSelectMediaTrackListWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyISingleSelectMediaTrackList = any ISingleSelectMediaTrackList

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.itimedmetadatatrackprovider)
public protocol ITimedMetadataTrackProvider : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.itimedmetadatatrackprovider.timedmetadatatracks)
    var timedMetadataTracks: WindowsFoundation.AnyIVectorView<UWP.TimedMetadataTrack?>! { get }
}

extension ITimedMetadataTrackProvider {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.ITimedMetadataTrackProviderWrapper.IID:
                let wrapper = __ABI_Windows_Media_Core.ITimedMetadataTrackProviderWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyITimedMetadataTrackProvider = any ITimedMetadataTrackProvider

extension UWP.AudioDecoderDegradation {
    public static var none : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_None
    }
    public static var downmixTo2Channels : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_DownmixTo2Channels
    }
    public static var downmixTo6Channels : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_DownmixTo6Channels
    }
    public static var downmixTo8Channels : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_DownmixTo8Channels
    }
}
extension UWP.AudioDecoderDegradation: @retroactive Hashable, @retroactive Codable {}

extension UWP.AudioDecoderDegradationReason {
    public static var none : UWP.AudioDecoderDegradationReason {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason_None
    }
    public static var licensingRequirement : UWP.AudioDecoderDegradationReason {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason_LicensingRequirement
    }
    public static var spatialAudioNotSupported : UWP.AudioDecoderDegradationReason {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason_SpatialAudioNotSupported
    }
}
extension UWP.AudioDecoderDegradationReason: @retroactive Hashable, @retroactive Codable {}

extension UWP.CodecCategory {
    public static var encoder : UWP.CodecCategory {
        __x_ABI_CWindows_CMedia_CCore_CCodecCategory_Encoder
    }
    public static var decoder : UWP.CodecCategory {
        __x_ABI_CWindows_CMedia_CCore_CCodecCategory_Decoder
    }
}
extension UWP.CodecCategory: @retroactive Hashable, @retroactive Codable {}

extension UWP.CodecKind {
    public static var audio : UWP.CodecKind {
        __x_ABI_CWindows_CMedia_CCore_CCodecKind_Audio
    }
    public static var video : UWP.CodecKind {
        __x_ABI_CWindows_CMedia_CCore_CCodecKind_Video
    }
}
extension UWP.CodecKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.FaceDetectionMode {
    public static var highPerformance : UWP.FaceDetectionMode {
        __x_ABI_CWindows_CMedia_CCore_CFaceDetectionMode_HighPerformance
    }
    public static var balanced : UWP.FaceDetectionMode {
        __x_ABI_CWindows_CMedia_CCore_CFaceDetectionMode_Balanced
    }
    public static var highQuality : UWP.FaceDetectionMode {
        __x_ABI_CWindows_CMedia_CCore_CFaceDetectionMode_HighQuality
    }
}
extension UWP.FaceDetectionMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaDecoderStatus {
    public static var fullySupported : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_FullySupported
    }
    public static var unsupportedSubtype : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_UnsupportedSubtype
    }
    public static var unsupportedEncoderProperties : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_UnsupportedEncoderProperties
    }
    public static var degraded : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_Degraded
    }
}
extension UWP.MediaDecoderStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaSourceState {
    public static var initial : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Initial
    }
    public static var opening : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Opening
    }
    public static var opened : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Opened
    }
    public static var failed : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Failed
    }
    public static var closed : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Closed
    }
}
extension UWP.MediaSourceState: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaSourceStatus {
    public static var fullySupported : UWP.MediaSourceStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceStatus_FullySupported
    }
    public static var unknown : UWP.MediaSourceStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceStatus_Unknown
    }
}
extension UWP.MediaSourceStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaStreamSourceClosedReason {
    public static var done : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_Done
    }
    public static var unknownError : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_UnknownError
    }
    public static var appReportedError : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_AppReportedError
    }
    public static var unsupportedProtectionSystem : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_UnsupportedProtectionSystem
    }
    public static var protectionSystemFailure : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_ProtectionSystemFailure
    }
    public static var unsupportedEncodingFormat : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_UnsupportedEncodingFormat
    }
    public static var missingSampleRequestedEventHandler : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_MissingSampleRequestedEventHandler
    }
}
extension UWP.MediaStreamSourceClosedReason: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaStreamSourceErrorStatus {
    public static var other : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_Other
    }
    public static var outOfMemory : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_OutOfMemory
    }
    public static var failedToOpenFile : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_FailedToOpenFile
    }
    public static var failedToConnectToServer : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_FailedToConnectToServer
    }
    public static var connectionToServerLost : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_ConnectionToServerLost
    }
    public static var unspecifiedNetworkError : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_UnspecifiedNetworkError
    }
    public static var decodeError : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_DecodeError
    }
    public static var unsupportedMediaFormat : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_UnsupportedMediaFormat
    }
}
extension UWP.MediaStreamSourceErrorStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaTrackKind {
    public static var audio : UWP.MediaTrackKind {
        __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind_Audio
    }
    public static var video : UWP.MediaTrackKind {
        __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind_Video
    }
    public static var timedMetadata : UWP.MediaTrackKind {
        __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind_TimedMetadata
    }
}
extension UWP.MediaTrackKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.MseAppendMode {
    public static var segments : UWP.MseAppendMode {
        __x_ABI_CWindows_CMedia_CCore_CMseAppendMode_Segments
    }
    public static var sequence : UWP.MseAppendMode {
        __x_ABI_CWindows_CMedia_CCore_CMseAppendMode_Sequence
    }
}
extension UWP.MseAppendMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.MseEndOfStreamStatus {
    public static var success : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_Success
    }
    public static var networkError : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_NetworkError
    }
    public static var decodeError : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_DecodeError
    }
    public static var unknownError : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_UnknownError
    }
}
extension UWP.MseEndOfStreamStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MseReadyState {
    public static var closed : UWP.MseReadyState {
        __x_ABI_CWindows_CMedia_CCore_CMseReadyState_Closed
    }
    public static var open : UWP.MseReadyState {
        __x_ABI_CWindows_CMedia_CCore_CMseReadyState_Open
    }
    public static var ended : UWP.MseReadyState {
        __x_ABI_CWindows_CMedia_CCore_CMseReadyState_Ended
    }
}
extension UWP.MseReadyState: @retroactive Hashable, @retroactive Codable {}

extension UWP.SceneAnalysisRecommendation {
    public static var standard : UWP.SceneAnalysisRecommendation {
        __x_ABI_CWindows_CMedia_CCore_CSceneAnalysisRecommendation_Standard
    }
    public static var hdr : UWP.SceneAnalysisRecommendation {
        __x_ABI_CWindows_CMedia_CCore_CSceneAnalysisRecommendation_Hdr
    }
    public static var lowLight : UWP.SceneAnalysisRecommendation {
        __x_ABI_CWindows_CMedia_CCore_CSceneAnalysisRecommendation_LowLight
    }
}
extension UWP.SceneAnalysisRecommendation: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedMetadataKind {
    public static var caption : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Caption
    }
    public static var chapter : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Chapter
    }
    public static var custom : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Custom
    }
    public static var data : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Data
    }
    public static var description : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Description
    }
    public static var subtitle : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Subtitle
    }
    public static var imageSubtitle : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_ImageSubtitle
    }
    public static var speech : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Speech
    }
}
extension UWP.TimedMetadataKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedMetadataTrackErrorCode {
    public static var none : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_None
    }
    public static var dataFormatError : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_DataFormatError
    }
    public static var networkError : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_NetworkError
    }
    public static var internalError : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_InternalError
    }
}
extension UWP.TimedMetadataTrackErrorCode: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextDisplayAlignment {
    public static var before : UWP.TimedTextDisplayAlignment {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextDisplayAlignment_Before
    }
    public static var after : UWP.TimedTextDisplayAlignment {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextDisplayAlignment_After
    }
    public static var center : UWP.TimedTextDisplayAlignment {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextDisplayAlignment_Center
    }
}
extension UWP.TimedTextDisplayAlignment: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextFlowDirection {
    public static var leftToRight : UWP.TimedTextFlowDirection {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextFlowDirection_LeftToRight
    }
    public static var rightToLeft : UWP.TimedTextFlowDirection {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextFlowDirection_RightToLeft
    }
}
extension UWP.TimedTextFlowDirection: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextFontStyle {
    public static var normal : UWP.TimedTextFontStyle {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextFontStyle_Normal
    }
    public static var oblique : UWP.TimedTextFontStyle {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextFontStyle_Oblique
    }
    public static var italic : UWP.TimedTextFontStyle {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextFontStyle_Italic
    }
}
extension UWP.TimedTextFontStyle: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextLineAlignment {
    public static var start : UWP.TimedTextLineAlignment {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextLineAlignment_Start
    }
    public static var end : UWP.TimedTextLineAlignment {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextLineAlignment_End
    }
    public static var center : UWP.TimedTextLineAlignment {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextLineAlignment_Center
    }
}
extension UWP.TimedTextLineAlignment: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextScrollMode {
    public static var popon : UWP.TimedTextScrollMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextScrollMode_Popon
    }
    public static var rollup : UWP.TimedTextScrollMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextScrollMode_Rollup
    }
}
extension UWP.TimedTextScrollMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextUnit {
    public static var pixels : UWP.TimedTextUnit {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextUnit_Pixels
    }
    public static var percentage : UWP.TimedTextUnit {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextUnit_Percentage
    }
}
extension UWP.TimedTextUnit: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextWeight {
    public static var normal : UWP.TimedTextWeight {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWeight_Normal
    }
    public static var bold : UWP.TimedTextWeight {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWeight_Bold
    }
}
extension UWP.TimedTextWeight: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextWrapping {
    public static var noWrap : UWP.TimedTextWrapping {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWrapping_NoWrap
    }
    public static var wrap : UWP.TimedTextWrapping {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWrapping_Wrap
    }
}
extension UWP.TimedTextWrapping: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedTextWritingMode {
    public static var leftRightTopBottom : UWP.TimedTextWritingMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode_LeftRightTopBottom
    }
    public static var rightLeftTopBottom : UWP.TimedTextWritingMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode_RightLeftTopBottom
    }
    public static var topBottomRightLeft : UWP.TimedTextWritingMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode_TopBottomRightLeft
    }
    public static var topBottomLeftRight : UWP.TimedTextWritingMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode_TopBottomLeftRight
    }
    public static var leftRight : UWP.TimedTextWritingMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode_LeftRight
    }
    public static var rightLeft : UWP.TimedTextWritingMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode_RightLeft
    }
    public static var topBottom : UWP.TimedTextWritingMode {
        __x_ABI_CWindows_CMedia_CCore_CTimedTextWritingMode_TopBottom
    }
}
extension UWP.TimedTextWritingMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.VideoStabilizationEffectEnabledChangedReason {
    public static var programmatic : UWP.VideoStabilizationEffectEnabledChangedReason {
        __x_ABI_CWindows_CMedia_CCore_CVideoStabilizationEffectEnabledChangedReason_Programmatic
    }
    public static var pixelRateTooHigh : UWP.VideoStabilizationEffectEnabledChangedReason {
        __x_ABI_CWindows_CMedia_CCore_CVideoStabilizationEffectEnabledChangedReason_PixelRateTooHigh
    }
    public static var runningSlowly : UWP.VideoStabilizationEffectEnabledChangedReason {
        __x_ABI_CWindows_CMedia_CCore_CVideoStabilizationEffectEnabledChangedReason_RunningSlowly
    }
}
extension UWP.VideoStabilizationEffectEnabledChangedReason: @retroactive Hashable, @retroactive Codable {}

